/dts-v1/;
#include "meson8.dtsi"
#include <dt-bindings/clock/meson8.h>
#include <dt-bindings/reset/aml_meson8m2_gate.h>
/{
	amlogic-dt-id = "m8m2_n200_2G";
	compatible = "AMLOGIC,mesonX";
	model = "AMLOGIC";
	#address-cells = <1>;
	#size-cells = <1>;
	aliases {
		serial0 = &uart_AO;
	};

	memory{
		device_type = "memory";
        	#address-cells = <1>;
        	#size-cells = <1>;

	};
	reserved-memory {
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;
		/* global autoconfigured region for contiguous allocations */
		secmon_reserved:linux,secmon {
			compatible = "aml_secmon_memory";
			reg = <0x06100000 0x03000000>;
			no-map;
		};
		fb_reserved:linux,meson-fb {
			compatible = "amlogic, fb-memory";
			size = <0x2000000>;
			no-map;
		};

		/*  DISP&MM-A/V stream */
		streambuf_reserved:linux,mesonstream {
			compatible = "amlogic, stream-memory";
			size = <0x2000000>;
			no-map;
		};

		/*  DISP&MM-A/V stream */
		vdec_reserved:linux,vdec {
			compatible = "amlogic, vdec-memory";
			size = <0xc000000>;
			no-map;
		};

		linux,cma {
			compatible = "shared-dma-pool";
			reusable;
			size = <0x4000000>;
			alignment = <0x2000>;
			linux,cma-default;
		};
        ion_reserved:linux,ion-dev {
            compatible = "amlogic, idev-mem";
            size = <0x2000000>;
        };
	};

    	psci {
		compatible = "arm,psci";
		method = "smc";
		cpu_suspend = <0xC4000001>;
		cpu_off = <0x84000002>;
		cpu_on = <0x84000003>;
		migrate = <0xC4000005>;
		reg=<0xc4300000 0x4000
			0xc110419c 0x4
			0xc81000e4 0x4
			0xc81000e0 0x4
			0xd9000000 0x20000
			0xc4300000 0x4000>;
	};
	secmon {
		compatible = "aml,secmon";
		memory-region = <&secmon_reserved>;
		in_base_func = <0x82000020>;
		out_base_func = <0x82000021>;
	};
    ion_dev {
        compatible = "amlogic, ion_dev";
        memory-region = <&ion_reserved>;
    };

	meson-vout {
		compatible = "amlogic, meson-vout";
		dev_name = "meson-vout";
		status = "okay";
	};
	meson-fb {
		compatible = "amlogic, meson-fb";
		memory-region = <&fb_reserved>;
		dev_name = "meson-fb";
		status = "okay";
		interrupts = <0 3 1
			0 57 1>;
		interrupt-names = "viu-vsync", "rdma";
		mem_size = <0x01800000 0x00100000>; /* fb0/fb1 memory size */
		vmode = <3>; /** 0:VMODE_720P 1:VMODE_LCD 2:VMODE_LVDS_1080P 3:VMODE_1080P */
		scale_mode = <1>; /** 0:VPU free scale 1:OSD free scale 2:OSD super scale */
		4k2k_fb = <0>;
		display_size_default = <1920 1080 1920 3240 32>; //1920*1080*4*3 = 0x17BB000
	};
	ge2d {
		compatible = "amlogic, ge2d";
		dev_name = "ge2d";
		status = "okay";
		interrupts = <0 150 1>;
		interrupt-names = "ge2d";
		resets = <&clock GCLK_IDX_GE2D>;
		reset-names = "ge2d";
	};

    mesonstream {
		compatible = "amlogic, codec, streambuf";
		memory-region = <&streambuf_reserved>;
                dev_name = "mesonstream";
                status = "okay";
		resets = <&clock GCLK_IDX_HIU_PARSER_TOP
			&clock GCLK_IDX_VPU_INTR
			&clock GCLK_IDX_DEMUX
			&clock GCLK_IDX_DOS
			&clock GCLK_IDX_MEDIA_CPU>;
			reset-names = "parser_top",
				"vpu_intr",
				"demux",
				"vdec",
				"audio";
			interrupts = <0 3 1
				0 23 1
				0 32 1
				0 43 1
				0 44 1
				0 45 1>;
			interrupt-names = "vsync",
					"demux",
					"parser",
					"mailbox_0",
					"mailbox_1",
					"mailbox_2";
    };

    vdec {
        compatible = "amlogic, vdec";
                memory-region = <&vdec_reserved>;
                dev_name = "vdec.0";
                status = "okay";
    };
	ethmac: ethernet@0xc9410000{
		compatible = "amlogic, meson8m2-rmii-dwmac";
		reg = <0xc9410000 0x10000
		0xc1108108 0x4>;
		interrupts = <0 8 1>;
		resets = <&clock GCLK_IDX_ETHERNET>;
		reset-names = "ethpower";
		interrupt-names = "macirq";
		clocks = <&clock CLK_81>;
		clock-names = "ethclk81";
	};
	meson-remote {
		compatible = "amlogic, meson, remote-keypad";
		dev_name = "meson-remote";
		status = "ok";
		interrupts = <0 15 1>;
		interrupt-names = "remoteirq";
	};
	meson-irblaster {
		compatible = "amlogic, am_irblaster";
		dev_name = "meson-irblaster";
		status = "ok";
	};

sdio{
        compatible = "amlogic, aml_sdio";
        dev_name = "aml_sdio.0";
        status = "okay";
        reg = <0xc1108c20 0x20>;
        interrupts = <	0 28 1
        				0 67 1
        				0 69 1>;
        pinctrl-names = "sd_clk_cmd_pins", "sd_all_pins", "emmc_clk_cmd_pins", "emmc_all_pins", "sdio_clk_cmd_pins", "sdio_all_pins","sd_1bit_pins"; // "jtag_pin", "uartao_default";
        pinctrl-0 = <&sd_clk_cmd_pins>;
        pinctrl-1 = <&sd_all_pins>;
        pinctrl-2 = <&emmc_clk_cmd_pins>;
        pinctrl-3 = <&emmc_all_pins>;
        pinctrl-4 = <&sdio_clk_cmd_pins>;
        pinctrl-5 = <&sdio_all_pins>;
        pinctrl-6 = <&sd_1bit_pins>;
	clocks = <&clock CLK_81>;
	clock-names = "host_clksrc";
        sd{
            status = "okay";
            port = <1>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
            pinname = "sd";
            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED";
            f_min = <300000>;
            f_max = <50000000>;
            f_max_w = <50000000>;
            max_req_size = <0x20000>;          /**128KB*/
            gpio_dat3 = <&gpio       CARD_4       GPIO_ACTIVE_HIGH>;
            jtag_pin =  <&gpio       CARD_0       GPIO_ACTIVE_HIGH>;
            gpio_cd =  <&gpio       CARD_6       GPIO_ACTIVE_HIGH>;
//            gpio_ro = "GPIOZ_0";
            irq_in = <3>;
            irq_out = <5>;
            card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
        };
//        emmc{
//            status = "ok";
//            port = <2>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
//            pinname = "emmc";
//            ocr_avail = <0x200000>;          /**VDD voltage 3.3 ~ 3.4 */
//            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_ERASE", "MMC_CAP_HW_RESET"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
//            f_min = <300000>;
//            f_max = <50000000>;
//            f_max_w = <50000000>;
//            max_req_size = <0x20000>;          /**128KB*/
//            gpio_dat3 = "BOOT_3";
//            card_type = <1>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
//        };
//	sdio{
//            status = "ok";
//            port = <0>;          /*0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
//            pinname = "sdio";
//            ocr_avail = <0x200000>;          /*VDD voltage 3.3 ~ 3.4 */
//            caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_SDIO_IRQ","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE";
//            f_min = <300000>;
//            f_max = <50000000>;
//            max_req_size = <0x20000>;          /**128KB*/
//            card_type = <3>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
//        };
    };

    sdhc{
        compatible = "amlogic, aml_sdhc";
        dev_name = "aml_sdhc.0";
        status = "okay";
        reg = <0xc1108e00 0x3c>;
        interrupts = <	0 78 1
        				0 67 1
        				0 69 1>;
        pinctrl-names = "sdhc_sd_clk_cmd_pins", "sdhc_sd_all_pins", "sdhc_emmc_clk_cmd_pins", "sdhc_emmc_all_pins", "sdhc_sdio_clk_cmd_pins", "sdhc_sdio_all_pins";
        pinctrl-0 = <&sdhc_sd_clk_cmd_pins>;
        pinctrl-1 = <&sdhc_sd_all_pins>;
        pinctrl-2 = <&sdhc_emmc_clk_cmd_pins>;
        pinctrl-3 = <&sdhc_emmc_all_pins>;
        pinctrl-4 = <&sdhc_sdio_clk_cmd_pins>;
        pinctrl-5 = <&sdhc_sdio_all_pins>;
        //pinctrl-6 = <&sd_1bit_pins>;
//		clocks = <&clock CLK_FPLL_DIV_3>;
//		clock-names = "host_clksrc";
		resets = <&clock GCLK_IDX_SDHC>;
		reset-names = "sdhc_gate";

        // sd{
        //     status = "okay";
        //     port = <4>;          /**0:sdhc_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
        //     pinname = "sd";
        //     ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
        //     caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED","MMC_CAP_UHS_SDR12","MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50","MMC_CAP_UHS_SDR104";
        //     f_min = <300000>;
        //     f_max = <100000000>;
        //     max_req_size = <0x20000>;          /**128KB*/
        //     gpio_dat3 = "CARD_4";
        //     //jtag_pin = "CARD_0";
        //     gpio_cd = "CARD_6";
        //     //gpio_ro = "GPIOZ_0";
        //     irq_in = <3>;
        //     irq_out = <5>;
        //     card_type = <5>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
        // };
        emmc{
            status = "okay";
            port = <5>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
            pinname = "emmc";
            ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
            caps = "MMC_CAP_8_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE","MMC_CAP_ERASE", "MMC_CAP_HW_RESET"; // MMC_CAP_NEEDS_POLL -- for detect, MMC_CAP_NONREMOVABLE -- for eMMC/TSD
            caps2 = "MMC_CAP2_HS200_1_8V_SDR";
	    	f_min = <300000>;
            f_max = <100000000>;
            max_req_size = <0x20000>;          /**128KB*/
            gpio_dat3 =  <&gpio       BOOT_3       GPIO_ACTIVE_HIGH>;
            card_type = <1>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
        };
        // sdio{
//            status = "okay";
        //     port = <3>;          /**0:sdio_a, 1:sdio_b, 2:sdio_c, 3:sdhc_a, 4:sdhc_b, 5:sdhc_c */
        //     pinname = "sdio";
//            ocr_avail = <0x00200080>; // 3.3:0x200000, 1.8+3.3:0x00200080
        //     caps = "MMC_CAP_4_BIT_DATA","MMC_CAP_MMC_HIGHSPEED","MMC_CAP_SD_HIGHSPEED", "MMC_CAP_NONREMOVABLE", "MMC_CAP_UHS_SDR12","MMC_CAP_UHS_SDR25","MMC_CAP_UHS_SDR50","MMC_CAP_UHS_SDR104";
//	    f_min = <300000>;
//            f_max = <100000000>;
//            max_req_size = <0x20000>;          /**128KB*/
        //     card_type = <3>; /* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD), 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card, 5:NON sdio device(means sd/mmc card), other:reserved */
//        };
    };
	pmu {
		compatible = "amlogic, aml_pmu_prober";
		#address-cells = <1>;
		#size-cells = <0>;
		driver_version = "v0.70";
		axp202 {
			compatible = "amlogic, axp_mfd";
			sub_type = "axp20_mfd";
			i2c_bus = "i2c_bus_ao";
			interrupts = <0 66 2>;
			reg = <0x34>;
			soft_limit_to99 = <0>;
			status = "disable";
		};
		aml1212 {
			compatible = "amlogic, amlogic_pmu";
			sub_type = "aml1212";
			i2c_bus = "i2c_bus_ao";
			interrupts = <0 66 2>;
			reg = <0x35>;
			soft_limit_to99 = <0>;
			status = "disable";
		};
		rn5t618 {
			compatible = "amlogic, ricoh_pmu";
			sub_type = "rn5t618";
			i2c_bus = "i2c_bus_ao";
			interrupts = <0 66 2>;
			reg = <0x32>;
			soft_limit_to99 = <0>;
			vbus_dcin_short_connect = <0>;
			status = "okay";
		};
		aml1216 {
			compatible = "amlogic, amlogic_pmu";
			sub_type = "aml1216_pmu";
			i2c_bus = "i2c_bus_ao";
			interrupts = <0 66 2>;
			reg = <0x35>;
			soft_limit_to99 = <0>;
			vbus_dcin_short_connect = <0>;
			status = "disable";
		};
		aml1218{
			compatible = "amlogic, amlogic_pmu";
			sub_type = "aml1218_pmu";
			i2c_bus = "i2c_bus_ao";
			interrupts = <0 66 2>;
			reg = <0x35>;
			soft_limit_to99 = <0>;
			vbus_dcin_short_connect = <1>;
			status = "disable";
		};
	};
	dwc2_b {
		compatible = "amlogic,dwc2";
		reg = <0xc90c0000 0x40000>;
		interrupts = <0 31 4>;
		status = "okay";
		pl-periph-id = <1>; /** lm name */
		clock-src = "usb1"; /** clock src */
		port-id = <1>;   /** ref to mach/usb.h */
		port-type = <1>;	/** 0: otg, 1: host, 2: slave */
		port-speed = <0>; /** 0: default, 1: high, 2: full */
		port-config = <0>; /** 0: default */
		port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
		port-id-mode = <1>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
		phy-reg = <0xc1108820>;
		phy-reg-size = <0x20>;
		usb-fifo = <1024>;
		host-only-core = <1>;
		pmu-apply-power = <1>;
		cpu-type = "meson8";
		resets = <&clock GCLK_IDX_USB_GENERAL
					&clock GCLK_IDX_MISC_USB1_TO_DDR
					&clock GCLK_IDX_USB1>;
		reset-names = "usb_general",
						"usb1",
						"usb1_to_ddr";
	};

	dwc2_a {
		compatible = "amlogic,dwc2";
		reg = <0xc9040000 0x40000>;
		interrupts = <0 30 4>;
		status = "okay";
		pl-periph-id = <0>; /** lm name */
		clock-src = "usb0"; /** clock src */
		port-id = <0>;  /** ref to mach/usb.h */
		port-type = <0>;	/** 0: otg, 1: host, 2: slave */
		port-speed = <0>; /** 0: default, high, 1: full */
		port-config = <0>; /** 0: default */
		port-dma = <0>; /** 0: default, 1: single, 2: incr, 3: incr4, 4: incr8, 5: incr16, 6: disable*/
		port-id-mode = <0>; /** 0: hardware, 1: sw_host, 2: sw_slave*/
		gpio-vbus-power = "GPIOZ_1";
		gpios = <&gpio       GPIOZ_1       GPIO_ACTIVE_HIGH>;
		gpio-work-mask	= <1>; /**0: work on pulldown,1:work on pullup*/
		phy-reg = <0xc1108800>;
		phy-reg-size = <0x20>;
		usb-fifo = <1024>;
		cpu-type = "meson8";
		resets = <&clock GCLK_IDX_USB_GENERAL
					&clock GCLK_IDX_MISC_USB0_TO_DDR
					&clock GCLK_IDX_USB0>;
		reset-names = "usb_general",
						"usb0",
						"usb0_to_ddr";
	};
	canvas{        compatible = "amlogic, meson, canvas";
        dev_name = "amlogic-canvas";
        status = "ok";
        reg = <0xc8006000 0x400>;
    };

	/* AUDIO board specific */
	dummy_codec:dummy{
		#sound-dai-cells = <0>;
		compatible = "amlogic, aml_dummy_codec";
		status = "okay";
	};
	aml_m8_snd {
		compatible = "aml, aml_snd_m8";
		status = "okay";
		aml-sound-card,format = "i2s";
		aml_sound_card,name = "AML-M8AUDIO";
		aml,audio-routing =
				"Ext Spk","LOUTL",
				"Ext Spk","LOUTR";

		mute_gpio = "GPIO_BSD_EN";
		hp_disable;
		hp_paraments = <800 300 0 5 1>;
		pinctrl-names = "aml_snd_m8";
		pinctrl-0 = <&audio_pins>;
		cpu_list = <&cpudai0 &cpudai1 &cpudai2>;
		codec_list = <&codec0 &codec1 &codec2>;
		plat_list = <&i2s_plat &i2s_plat &pcm_plat>;
		cpudai0: cpudai0 {
			sound-dai = <&i2s_dai>;
		};
		cpudai1: cpudai1 {
			sound-dai = <&spdif_dai>;
		};
		cpudai2: cpudai2 {
			sound-dai = <&pcm_dai>;
		};
		codec0: codec0 {
			sound-dai = <&dummy_codec>;
		};
		codec1: codec1 {
			sound-dai = <&spdif_codec>;
		};
		codec2: codec2 {
			sound-dai = <&pcm_codec>;
		};
	};
	/* END OF AUDIO board specific */

	efuse{
		compatible = "amlogic, efuse";
		read_cmd = <0x82000030>;
		write_cmd = <0x82000031>;
		plat-pos = <0 454>;
		plat-count = <48>;
		usid-min = <8>; /*reserved*/
		usid-max = <31>; /*reserved*/
	};
}; /* end of / */
&uart_AO {
	status="okay";
};

&i2c_ao {
  status = "okay";
};

&i2c_b {
  status = "okay";
};

&i2c_c {
  status = "okay";
};
&i2c_d {
  status = "okay";
};

&amhdmitx {
	vend-data = <&vend_data>;

	vend_data: vend_data{
	    vendor_name = "Amlogic";           /* Max Chars: 8     */
	    vendor_id = <0x000000>;                 /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
	    product_desc = "M8M2 Mbox";        /* Max Chars: 16    */
	    cec_osd_string = "Amlogic MBox";        /* Max Chars: 14    */
	};
};

&pinmux {
	audio_pins:audio_pin{
		amlogic,setmask=<3 0x78000000
				10 0x78000000>;
		amlogic,clrmask=<4 0x3c000
				5 0x1000>;
		amlogic,pins = "GPIOX_4","GPIOX_5","GPIOX_6","GPIOX_7",
					"GPIOAO_8","GPIOAO_9","GPIOAO_10","GPIOAO_11";
	};
	audio_spdif_pins:audio_pin1{
		amlogic,setmask=<1 0x80>;
		amlogic,clrmask=<1 0x10000>;
		amlogic,pins ="GPIOY_3";
	};
};
